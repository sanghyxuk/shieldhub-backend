# 웹 취약점 분석 API 문서

## 목차
- [개요](#개요)
- [인증](#인증)
- [API 엔드포인트](#api-엔드포인트)
- [데이터 모델](#데이터-모델)
- [에러 처리](#에러-처리)
- [테스트 방법](#테스트-방법)

---

## 개요

ShieldHub 백엔드 서버는 웹사이트 취약점 분석을 위한 RESTful API를 제공합니다. 
이 API는 Flask AI 서버와 연동하여 웹사이트의 보안 취약점을 자동으로 탐지하고 분석합니다.

**기본 URL**: `http://localhost:8080`

**Flask AI 서버 URL**: `http://127.0.0.1:5001`

---

## 인증

모든 웹 취약점 분석 API는 JWT 토큰 기반 인증이 필요합니다.

### 인증 헤더 형식
```
Authorization: Bearer {JWT_TOKEN}
```

### JWT 토큰 획득 방법
로그인 API를 통해 JWT 토큰을 받을 수 있습니다.

**엔드포인트**: `POST /api/auth/login`

**요청 예시**:
```json
{
  "username": "testuser",
  "password": "password123"
}
```

**응답 예시**:
```json
{
  "success": true,
  "message": "로그인 성공",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "username": "testuser",
  "requiresOtp": false
}
```

---

## API 엔드포인트

### 1. 웹 취약점 분석 시작

웹사이트 URL을 받아 보안 취약점 분석을 시작합니다.

#### 요청

- **URL**: `/api/analysis/start`
- **Method**: `POST`
- **인증**: 필수 (JWT Bearer Token)
- **Content-Type**: `application/json`

#### 요청 본문

```json
{
  "url": "https://example.com"
}
```

**필드 설명**:
- `url` (string, 필수): 분석할 웹사이트의 URL

#### 성공 응답

**Status Code**: `200 OK`

```json
{
  "success": true,
  "url": "https://example.com",
  "vulnerability_count": 3,
  "vulnerabilities": [
    {
      "type": "XSS",
      "severity": "HIGH",
      "pattern": "<script>alert('xss')</script>",
      "details": "Detected XSS vulnerability in search parameter",
      "confidence": 0.95
    },
    {
      "type": "SQL_INJECTION",
      "severity": "CRITICAL",
      "pattern": "' OR '1'='1",
      "details": "SQL injection vulnerability found in login form",
      "confidence": 0.89
    },
    {
      "type": "CSRF",
      "severity": "MEDIUM",
      "pattern": "Missing CSRF token",
      "details": "Form submission without CSRF protection",
      "confidence": 0.78
    }
  ]
}
```

**응답 필드 설명**:
- `success` (boolean): 분석 성공 여부
- `url` (string): 분석된 URL
- `vulnerability_count` (integer): 발견된 취약점 개수
- `vulnerabilities` (array): 취약점 상세 정보 배열
  - `type` (string): 취약점 유형 (XSS, SQL_INJECTION, CSRF 등)
  - `severity` (string): 심각도 (CRITICAL, HIGH, MEDIUM, LOW)
  - `pattern` (string): 탐지된 패턴
  - `details` (string): 취약점 상세 설명
  - `confidence` (number): 탐지 신뢰도 (0.0 ~ 1.0)

#### 실패 응답

**Status Code**: `400 Bad Request`

```json
{
  "success": false,
  "message": "AI 서버 통신 중 오류가 발생했습니다."
}
```

**일반적인 에러 메시지**:
- `"분석할 URL은 필수입니다."`: URL이 제공되지 않음
- `"사용자를 찾을 수 없습니다"`: 인증된 사용자 정보가 유효하지 않음
- `"AI 서버 통신 중 오류가 발생했습니다."`: Flask AI 서버와의 통신 실패

---

## 데이터 모델

### 취약점 심각도 (Severity)

| 값 | 설명 |
|---|---|
| `CRITICAL` | 매우 심각한 취약점, 즉시 조치 필요 |
| `HIGH` | 높은 위험도, 빠른 시일 내 조치 필요 |
| `MEDIUM` | 중간 위험도 |
| `LOW` | 낮은 위험도 |

### 취약점 유형 (Vulnerability Type)

주요 취약점 유형:
- `XSS` (Cross-Site Scripting): 악성 스크립트 삽입 취약점
- `SQL_INJECTION`: SQL 인젝션 공격 취약점
- `CSRF` (Cross-Site Request Forgery): 요청 위조 취약점
- `COMMAND_INJECTION`: 명령어 실행 취약점
- `PATH_TRAVERSAL`: 경로 조작 취약점
- `XXE` (XML External Entity): XML 외부 엔티티 취약점
- `SSRF` (Server-Side Request Forgery): 서버측 요청 위조
- `OPEN_REDIRECT`: 오픈 리다이렉트 취약점

---

## 에러 처리

### HTTP 상태 코드

| 상태 코드 | 설명 |
|---|---|
| `200 OK` | 요청 성공 |
| `400 Bad Request` | 잘못된 요청 (유효성 검증 실패) |
| `401 Unauthorized` | 인증 실패 (토큰 없음 또는 유효하지 않음) |
| `403 Forbidden` | 권한 없음 |
| `500 Internal Server Error` | 서버 내부 오류 |

### 에러 응답 형식

```json
{
  "success": false,
  "message": "에러 메시지"
}
```

---

## 테스트 방법

### 1. cURL을 이용한 테스트

#### Step 1: 로그인하여 JWT 토큰 획득

```bash
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "password": "password123"
  }'
```

**응답에서 `token` 값을 복사합니다.**

#### Step 2: 웹 취약점 분석 요청

```bash
curl -X POST http://localhost:8080/api/analysis/start \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -d '{
    "url": "https://www.naver.com"
  }'
```

`YOUR_JWT_TOKEN`을 실제 토큰으로 교체하세요.

---

### 2. Postman을 이용한 테스트

#### Step 1: 로그인

1. **Method**: POST
2. **URL**: `http://localhost:8080/api/auth/login`
3. **Headers**:
   - `Content-Type: application/json`
4. **Body** (raw JSON):
   ```json
   {
     "username": "testuser",
     "password": "password123"
   }
   ```
5. **Send** 버튼 클릭
6. 응답에서 `token` 값 복사

#### Step 2: 취약점 분석 요청

1. **Method**: POST
2. **URL**: `http://localhost:8080/api/analysis/start`
3. **Headers**:
   - `Content-Type: application/json`
   - `Authorization: Bearer YOUR_JWT_TOKEN`
4. **Body** (raw JSON):
   ```json
   {
     "url": "https://example.com"
   }
   ```
5. **Send** 버튼 클릭

---

### 3. JavaScript/Axios를 이용한 프론트엔드 연동

#### 로그인

```javascript
import axios from 'axios';

const API_BASE_URL = 'http://localhost:8080';

// 로그인
const login = async (username, password) => {
  try {
    const response = await axios.post(`${API_BASE_URL}/api/auth/login`, {
      username,
      password
    });
    
    if (response.data.success) {
      // JWT 토큰 저장
      localStorage.setItem('token', response.data.token);
      return response.data;
    }
  } catch (error) {
    console.error('Login error:', error);
    throw error;
  }
};
```

#### 웹 취약점 분석 요청

```javascript
// 취약점 분석 시작
const startAnalysis = async (url) => {
  try {
    const token = localStorage.getItem('token');
    
    const response = await axios.post(
      `${API_BASE_URL}/api/analysis/start`,
      { url },
      {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    return response.data;
  } catch (error) {
    console.error('Analysis error:', error);
    throw error;
  }
};

// 사용 예시
const analyzeWebsite = async () => {
  try {
    const result = await startAnalysis('https://example.com');
    
    console.log('Analysis completed!');
    console.log('Total vulnerabilities:', result.vulnerability_count);
    
    result.vulnerabilities.forEach((vuln, index) => {
      console.log(`\nVulnerability ${index + 1}:`);
      console.log(`  Type: ${vuln.type}`);
      console.log(`  Severity: ${vuln.severity}`);
      console.log(`  Details: ${vuln.details}`);
      console.log(`  Confidence: ${(vuln.confidence * 100).toFixed(2)}%`);
    });
  } catch (error) {
    console.error('Failed to analyze:', error.message);
  }
};
```

---

### 4. React 컴포넌트 예시

```javascript
import React, { useState } from 'react';
import axios from 'axios';

const VulnerabilityScanner = () => {
  const [url, setUrl] = useState('');
  const [loading, setLoading] = useState(false);
  const [results, setResults] = useState(null);
  const [error, setError] = useState(null);

  const handleAnalysis = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    setResults(null);

    try {
      const token = localStorage.getItem('token');
      
      const response = await axios.post(
        'http://localhost:8080/api/analysis/start',
        { url },
        {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          }
        }
      );

      setResults(response.data);
    } catch (err) {
      setError(err.response?.data?.message || '분석 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="vulnerability-scanner">
      <h2>웹 취약점 분석</h2>
      
      <form onSubmit={handleAnalysis}>
        <input
          type="url"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          placeholder="분석할 웹사이트 URL 입력"
          required
        />
        <button type="submit" disabled={loading}>
          {loading ? '분석 중...' : '분석 시작'}
        </button>
      </form>

      {error && (
        <div className="error">
          <p>{error}</p>
        </div>
      )}

      {results && results.success && (
        <div className="results">
          <h3>분석 결과</h3>
          <p>URL: {results.url}</p>
          <p>발견된 취약점: {results.vulnerability_count}개</p>

          {results.vulnerabilities.length > 0 && (
            <div className="vulnerabilities">
              <h4>취약점 목록</h4>
              {results.vulnerabilities.map((vuln, index) => (
                <div key={index} className={`vuln-item severity-${vuln.severity.toLowerCase()}`}>
                  <h5>{vuln.type}</h5>
                  <p><strong>심각도:</strong> {vuln.severity}</p>
                  <p><strong>패턴:</strong> {vuln.pattern}</p>
                  <p><strong>상세:</strong> {vuln.details}</p>
                  <p><strong>신뢰도:</strong> {(vuln.confidence * 100).toFixed(2)}%</p>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default VulnerabilityScanner;
```

---

## 데이터베이스 저장

분석 결과는 다음 테이블에 자동으로 저장됩니다:

### 1. AnalysisResults
- 분석 요청 및 결과 메타데이터
- `analysis_id` (PK)
- `user_id`: 요청한 사용자
- `url_to_analyze`: 분석된 URL
- `analysis_status`: 상태 (PENDING, COMPLETED, FAILED)
- `analysis_date`: 분석 시작 시간
- `completion_date`: 분석 완료 시간
- `error_message`: 오류 메시지 (실패 시)

### 2. Vulnerabilities
- 취약점 정보 (중복 방지)
- `vulnerability_id` (PK)
- `vulnerability_type`: 취약점 유형
- `severity`: 심각도
- `detected_pattern`: 탐지된 패턴
- `details`: 상세 설명

### 3. AnalysisVulnerabilities
- 분석 결과와 취약점 연결 (N:M 관계)
- `analysis_id` (FK)
- `vulnerability_id` (FK)
- `details`: 해당 분석에서의 상세 정보

---

## 주의사항

### 1. Flask AI 서버 실행 확인
웹 취약점 분석 API를 사용하기 전에 Flask AI 서버가 실행 중이어야 합니다.

**Flask 서버 실행 방법**:
```bash
cd path/to/flask-server
python app.py
```

Flask 서버는 `http://127.0.0.1:5001`에서 실행되어야 합니다.

### 2. CORS 설정
프론트엔드에서 API를 호출할 때 CORS 정책에 의해 차단될 수 있습니다.
현재 설정: `http://localhost:3000`만 허용

다른 도메인에서 접근이 필요한 경우 `application.yml`의 CORS 설정을 수정하세요:
```yaml
spring:
  web:
    cors:
      allowed-origins: "http://localhost:3000,http://your-domain.com"
```

### 3. 분석 시간
- 대규모 웹사이트의 경우 분석에 시간이 소요될 수 있습니다
- 프론트엔드에서 적절한 로딩 UI를 표시하는 것을 권장합니다

### 4. 보안
- JWT 토큰은 안전하게 저장하고 관리해야 합니다
- 프로덕션 환경에서는 HTTPS를 사용하세요
- `application.yml`의 시크릿 키를 변경하세요

---

## 트러블슈팅

### 문제 1: "Unauthorized" 에러
**원인**: JWT 토큰이 없거나 유효하지 않음
**해결**: 로그인하여 새 토큰을 받아 헤더에 포함시키세요

### 문제 2: "Flask 서버 통신 중 오류"
**원인**: Flask AI 서버가 실행되지 않았거나 연결할 수 없음
**해결**: 
1. Flask 서버가 실행 중인지 확인
2. `application.yml`의 Flask 서버 URL이 올바른지 확인
3. 방화벽 설정 확인

### 문제 3: "No enum constant Severity.CRITICAL"
**원인**: Flask 서버에서 보내는 severity 값의 대소문자가 일치하지 않음
**해결**: 이미 수정됨 - `toUpperCase()` 처리 추가됨

### 문제 4: CORS 에러
**원인**: 허용되지 않은 도메인에서 API 호출
**해결**: `application.yml`의 CORS 설정에 해당 도메인 추가

---

## 업데이트 내역

### 2025-11-21
- Severity Enum 대소문자 처리 버그 수정
- Flask 응답의 severity 값을 대문자로 변환하여 처리
- API 문서 초안 작성

---

## 연락처

문의사항이나 버그 리포트는 프로젝트 관리자에게 연락하세요.

